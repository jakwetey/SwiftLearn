-------5/11/2022-------
---DATA DEFINITION LANGUAGE (DDL) COMMAMDS
--CREATE -- create databases/tables/schemas
--ALTER -- modifies an existing table
---DROP -- remove or delete an entire table or constraint
--TRUNCTATE -- removes all records from a table but maintans the structure.

---SYNTAX
-- CREATE DATABASE DATABASENAME;

--CREATEING DATABASE COMPANY_DB
CREATE DATABASE COMPANY_DB;

----SYNTAX
--CREATE TABLE TABLENAME
--(
--COLUMNNAME DATATYPE CONSTRAINT,
--COLUMNNAME2 DATATYPE CONSTRAINT,
--COLUMNNAME3 DATATYPE CONSTRAINT,
--COLUMNNAME4 DATATYPE CONSTRAINT,
--...
--);

--CREATING EMPLOYEE TABLE
CREATE TABLE EMPLOYEE
(
EMP_ID  INT IDENTITY(1000, 1),
FNAME VARCHAR(50) NOT NULL,
LNAME VARCHAR(50) NOT NULL,
DOB DATE NOT NULL,
GENDER CHAR(1) NULL,
PHONE CHAR(10) NULL,
CITY VARCHAR(20) NOT NULL,
STATE CHAR(2) NOT NULL,
ZIP CHAR(5) NOT NULL
);

---PRIMARY KEY IS A UNIQUE IDENTIFIER IN A TABLE

-- SYNTAX
--ALTER TABLE TABLENAME
--ADD CONSTRAINT CONSTRAINTNAME PRIMARY KEY(COLUMNNAME);

--ADDING PK TO EMPLOYEE TABLE
ALTER TABLE EMPLOYEE
ADD CONSTRAINT PK_EMPLOYEE_EMP_ID PRIMARY KEY (EMP_ID);

--CREATING DEPARTMENT TABLE
CREATE TABLE DEPARTMENT
(
DEP_ID VARCHAR(5) NOT NULL,
DEP_NAME VARCHAR(50) NOT NULL,
DEP_STATE CHAR(2) NULL
);

-- ADDING PK CONSTRAINT
ALTER TABLE DEAPARTMENT
ADD CONSTRAINT PK_DEPARTMENT_DEP_ID PRIMARY KEY (DEP_ID);


--SYNTAX
--ALTER TABLE TABLENAME
--ADD COLUMNNMAE DATATYPE CONSTRAINT;

---ADDING COLUMN TO EMPLOYEE
ALTER TABLE EMPLOYEE
ADD DEP_ID VARCHAR(5) NOT NULL;

--FOREIGN KEY
-- A COLUMN OR FIELD IN ONE TABLE THAT REFERS TO THE PRIMARY KEY COLUMN IN 
--ANOTHER TABLE.

--SYNTAX
--ALTER TABLE CHILDTABLE
--ADD CONSTRAINT CONSTRAINTNME FOREIGN KEY (COLUMN)
--REFERENCES PARENTTABLE(COLUMN)

--ADDING FK TO EMPLOYEE TABLE
ALTER TABLE EMPLOYEE
ADD CONSTRAINT FK_EMPLOYEE_DEP_ID FOREIGN KEY(DEP_ID)
REFERENCES DEPARTMENT(DEP_ID);

---RENAMING TABLE
EXEC SP_RENAME 'DEAPARTMENT', 'DEPARTMENT';

-- SYNTAX
--ALTER TABLE TABLENAME
--ALTER COLUMN COLUMNNAME DATATYPE CONSTRAINT;

--MODIFYING PHONE DATATYPE
ALTER TABLE EMPLOYEE
ALTER COLUMN PHONE CHAR(12);

--ADDING SSN COLUMN 
ALTER TABLE EMPLOYEE
ADD SSN CHAR(9) NOT NULL;

--DROP
--SYNTAX
--ALTER TABLE TABLENAME
--DROP COLUMN COLUMNNAME;

---REMOVING SSN COLUMN
ALTER TABLE EMPLOYEE
DROP COLUMN SSN;

--UNIQUE CONSTRAINT ENSURES THAT ALL VALUES IN A COLUMN ARE DISTINCT.
--AND THERE CAN BE MORE THAN ONE DEFINED ON A TABLE

--ADDING UNIQUE CONSTRAINT TO SSN COLUMN
ALTER TABLE EMPLOYEE 
ADD CONSTRAINT UQ_EMPLOYEE_SSN UNIQUE(SSN);

-- DEFAULT CONSTRAINT WILL AUTOMATICALLY ASSIGN A VALUE IF NO VALUE WAS INSTERED.
-- ADDING DEFAULT VALUE OF N FOR GENDER WHEN NO VALUE IS SPECIFIED
ALTER TABLE EMPLOYEE
ADD CONSTRAINT DFT_EMPLOYEE_GENDER DEFAULT ('N') FOR GENDER;

--CHECK CONSTRAINT VERIFIES THAT ALL VALUES IN A FIELD SATISFY A GIVEN CONDITION.
-- ADDING CHECK TO VERIFY EMPLOYEE STATE
ALTER TABLE EMPLOYEE
ADD CONSTRAINT CHK_EMPLOYEE_STATE CHECK (STATE IN ('DC', 'MD', 'VA'));


-------5/12/2022-------
---ADDING CHECK CONSTRAINT TO VERIFY SSN LENGHT
ALTER TABLE EMPLOYEE
ADD CONSTRAINT CHK_EMPLOYEE_SSN CHECK (LEN(SSN) = 9);

CREATE TABLE DEPARTMENT1
(
DEP_ID VARCHAR(5) NOT NULL,
DEP_NAME VARCHAR(50) NOT NULL,
DEP_STATE CHAR(2) NULL
);

---DROP
--SYNTAX
--DROP TABLE TABLENAME

--DELETING DEPARTMENT1 TABLE
DROP TABLE DEPARTMENT1;

--TRUNCATE 
--SYNTAX
--TRUNCATE TABLE TABLENAME

---SYNTAX
--ALTER TABLE TABLENAME
--DROP COLUMN COLUMNNAME;

---REMOVING DEP_STATE COLUMN FROM DEPARTMENT1 TABLE
ALTER TABLE DEPARTMENT1
DROP COLUMN DEP_STATE;

---SYNTAX
--ALTER TABLE TABLENAME
--ADD  COLUMNNAME DATATYPE CONSTRAINT;

--- ADDING A HEADCOUNT COLUMN TO DEPARTMENT1 TABLE
ALTER TABLE DEPARTMENT1
ADD HEADCOUNT INTEGER NOT NULL;

---INDEXES ARE USED TO RETRIEVE DATA FROM DATABASES MORE QUICK, THEY HELP SPEED UP QUERIES.
----CLUSTERED 
--Whenever you apply clustered indexing in a table, it will perform sorting 
--in that table only. You can create only one clustered index in a table like primary key.
--Clustered index is as same as dictionary where the data is arranged by alphabetical order. 
--If you apply primary key to any column, then automatically it will become clustered index. 

----NONCLUSTERED
--is similar to the index of a book. The index of a book consists of a chapter name and page number, 
--if you want to read any topic or chapter then you can directly go to that page by using index of
-- that book. No need to go through each and every page of a book. 

---SYNTAX
--CREATE <CLUSTERED/ NONCLUSTERED> INDEXNAME ON TABLENAME(COLUMNNAME)

---CREATING INDEX ON PHONE COLUMN
CREATE NONCLUSTERED INDEX IDX_EMPLOYEE_PHONE ON EMPLOYEE(PHONE);

---SYNTAX
--DROP INDEX TABLENAME.INDEXNAME

--- REMOVING INDEX FROM PHONE COLUMN
DROP INDEX EMPLOYEE.IDX_EMPLOYEE_PHONE;

---DML COMMANDS (DATA MANIPULATION LAMGUAGE)
--INSERT POPULATE RECORDS
--UPDATE MODIFIES AN EXISTING RECORD BASED ON A GIVEN CONDITION
--DELETE REMOVES EXISTING RECORDS(BASED ON A GIVEN CONDITION)
--SELECT RETRIEVE RECORDS FROM ONE OR MORE TABLES.

--INSERT
--SYNTAX
--INSERT INTO TABLENAME (COLUMN1, COLUMN2, COLUMN3,...)
--VALUES 
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3');

--POPULATING DEPARTMENT TABLE
INSERT INTO DEPARTMENT (DEP_ID, DEP_NAME, DEP_STATE)
VALUES
(00001, 'IT', 'CA'),
(00002, 'CLAIMS', 'OH'),
(00003, 'UNDERWRITTING', 'DE'),
(00004, 'CUSTOMER', 'MD'),
(00005, 'SALES', NULL);

--RETRIEVING FROM DEPARTMENT TABLE
SELECT * FROM DEPARTMENT;

INSERT INTO DEPARTMENT (DEP_ID, DEP_NAME)
VALUES
(00011, 'CALL CENTER');

---POPULATING EMPLOYEE TABLE
INSERT INTO EMPLOYEE (FNAME, LNAME,DOB, GENDER, PHONE, CITY, STATE, ZIP,DEP_ID,SSN)
VALUES
('JOHN', 'SMITH', '05-10-1990', 'M', '443-123-9876', 'BALTIMORE', 'MD', '21117',00001, '123456789'),
('DAVE', 'JONES', '03-10-1800', 'M', '443-478-9876', 'COLUMBIA', 'MD', '21617',00005, '123457489'),
('EBONY', 'ALEZ', '05-10-1997', 'F', '813-123-9876', 'RESTON', 'VA', '20117',00003, '123456009'),
('DESTINY', 'OSEI', '01-10-2000', 'F', '440-123-9876', 'WASHINGTON', 'DC', '61117',00001, '003456789'),
('MICHAEL', 'DOE', '05-10-1990', 'M', '443-123-9006', 'BALTIMORE', 'MD', '21117',00002, '124866789');

--RETRIEVING FROM EMPLOYEES TABLE
SELECT * FROM EMPLOYEE

INSERT INTO EMPLOYEE (FNAME, LNAME,DOB, GENDER, PHONE, CITY, STATE, ZIP,DEP_ID,SSN)
VALUES
('JOHN', 'SAGE', '05-10-1990', 'M', '443-123-9876', 'HOUSTON', 'DC', '21117',00011, '734067999');

---UPDATE 
---SYNTAX
--UPDATE TABLENAME
--SET COLUMNNAME = 'NEWVALUE'
--WHERE CONDITION

---UPDATING EMPLOYEE PHONE NUMBER
UPDATE EMPLOYEE
SET PHONE = '701-677-9321'
WHERE EMP_ID = 1002;

--UPDATING EMPLOYEE LASTNAME
UPDATE EMPLOYEE
SET LNAME = 'RENDEL'
WHERE EMP_ID = 1003;


------05/16/2022
ALTER TABLE EMPLOYEE
ADD DEPARTMENT VARCHAR(20);

SELECT * FROM EMPLOYEE
SELECT * FROM DEPARTMENT

-- UPDATING EMPLOYEE TABLE TO DYNAMICALLY POLULATE DEPARTMENT COLUMN
UPDATE EMPLOYEE
SET DEPARTMENT = DEPARTMENT.DEP_NAME
FROM EMPLOYEE, DEPARTMENT
WHERE EMPLOYEE.DEP_ID = DEPARTMENT.DEP_ID

---DELETE
---SYNTAX 
--DELETE 
--FROM TABLE NAME
--WHERE CONDITION (---IF THERE IS NO CONDITION THEN EVERY RECORD WILL BE DELETED)

---- REMOVING EMPLOYEE JOHN SAGE RECORD
DELETE
FROM EMPLOYEE
WHERE EMP_ID = 1012;

SELECT * FROM EMPLOYEE;

DELETE 
FROM EMPLOYEE;

----REMOVE ALL RECORDS FROM DEPARTMENT
TRUNCATE TABLE DEPARTMENT;

SELECT * FROM DEPARTMENT;

-- REMOVING FK CONSTRAINT
ALTER TABLE EMPLOYEE
DROP [FK_EMPLOYEE_DEP_ID];

SELECT * FROM EMPLOYEE

---REMOVING EMPLOYEE TABLE FROM COMPANYDB
DROP TABLE EMPLOYEE;


--KEYED IN ORDER
--SELECT -- RETRIEVE THE DATE. LIST OF COLUMNS, DERIVED COLUMNS(AGGREGATED)
--FROM -- SPECIFIES THE TABLE(S) WHERE COLUMNS ARE SITUATED
--WHERE -- USED TO FILTER RECORDS ON A GIVEN CONDITION (NON-AGGREGATED COLUMNS)
--GROUP BY -- USED TO GROUP NON-AGGREGATED COLUMNS WHENEVER AN AGGREGATED FUNCTION IS 
			-- INTRODUCED IN THE SELECT
--HAVING -- USED TO FILTER AGGREGATED COLUMNS
--ORDER BY -- USED TO SORT OR ORDER RECODS. BY DEFAULT IN ASCENDING(ASC) 
			--OTHERWISE DESCENDING (DESC).

--LOGICAL  QUERY ORDER
--FROM
--WHERE
--GROUP BY
--HAVING
--SELECT 
--ORDER BY


--AGGREGATE FUNCTIONS
--SUM()
--COUNT()
--AVERAGE() / AVG()
--MAX()
--MIN()

--- F(X) = 2X + 4
--- F(2) = 2(2) + 4 = 8

---FIND THE HIGHEST UNIT PRICE ACROSS ALL PRODUCTS
SELECT MAX(UNITPRICE) AS MAXPRICE
FROM PRODUCTION.PRODUCTS;

SELECT UNITPRICE
FROM PRODUCTION.PRODUCTS
ORDER BY UNITPRICE DESC;

-- WHAT IS THE TOTAL NUMBER OF EMPLOYEES IN OUR COMPANY?
SELECT COUNT(EMPID) AS NUMOFEMPLOYEES
FROM HR.EMPLOYEES;

--FIND THE TOTAL UNITPRICE PER CATEGORY
SELECT CATEGORYID, SUM(UNITPRICE) AS TOTAL
FROM PRODUCTION.PRODUCTS
GROUP BY CATEGORYID
ORDER BY CATEGORYID;


--DISTINCT -- ALLOW RETRIEVAL OF NON DUPLICATED RECORDS
SELECT DISTINCT CATEGORYID
FROM PRODUCTION.PRODUCTS

---SQL OPERATORS
--AND -- ALL CONDITIONS MUST BE TRUE
--OR -- AT LEAST ONE CONDITION MUST BE TRUE
--BETWEEN IS USED AS A SEARCH PREDICATE FOR A RANGE OF ITEMS(ALWAYS USED WITH AND)
--IN -- ALLOWS TO CREATE A SET PREDICATE FOR A SET OF ITEMS
--LIKE -- ALLOWS TO PERFORM PATTERN SEARCH. 
		-- MUST BE ALWAYS USED WITH A WILDCARD FOR A GIVEN SEARCH.

-- PULL ORDERS PLACED FROM 11/2006 TO 11/2007
SELECT ORDERID, ORDERDATE
FROM SALES.ORDERS
WHERE ORDERDATE BETWEEN '11-01-2006' AND '11-01-2007'
ORDER BY ORDERDATE DESC;

SELECT ORDERID, ORDERDATE
FROM SALES.ORDERS
WHERE ORDERDATE >= '11-01-2006' AND ORDERDATE <= '11-01-2007';

--RETRIEVE A LIST OF PRODUCTS THAT UNTPRICE IS LESS THAN $10 OR MORE THAN $50
SELECT PRODUCTID, PRODUCTNAME, UNITPRICE
FROM PRODUCTION.PRODUCTS
WHERE UNITPRICE < 10 OR UNITPRICE > 50
ORDER BY UNITPRICE;

SELECT DISTINCT CUSTID, ORDERID
FROM SALES.ORDERS;


---05/17/2022
SELECT * FROM SALES.CUSTOMERS

--IN OPERATOR
--RETRIEVE CUSTOMERS FROM UK, SPAIN, MEXICO, BRAZIL USA, ITALY
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY IN ('UK', 'SPAIN', 'MEXICO', 'BRAZIL', 'USA', 'ITALY');

SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY ='UK' OR COUNTRY = 'SPAIN'OR COUNTRY = 'MEXICO'
		OR COUNTRY ='BRAZIL' OR COUNTRY = 'USA' OR COUNTRY = 'ITALY';

--LIKE OPERATOR
-- WILDCARDS(%, _)
-----% REPRESENTS MULTIPLE CHARACTERS
-----  _ REPRESENTS A SINGLE CHARACTER

SELECT DISTINCT COUNTRY
FROM SALES.CUSTOMERS

---PULL ALL CUSTOMER COUNTRIES THAT HAVE THE LETTER Z IN THERE
SELECT  DISTINCT COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '%Z%';

---PULL ALL CUSTOMER COUNTRIES THAT BEGIN WITH THE LETTER B.
SELECT DISTINCT COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE 'B%'

---PULL ALL CUSTOMER COUNTRIES THAT HAS THE LETTER 'A' IN THE 4TH POSITION.
SELECT DISTINCT COUNTRY 
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '___A%'

---PULL ALL CUSTOMER COUNTRIES THAT ENDS WITH LETTER D
SELECT DISTINCT COUNTRY 
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '%D';

---!= / <>
-- RERIEVE CUSTOMERS NOT FROM USA
SELECT CUSTID, COMPANYNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY != 'USA';

SELECT CUSTID, COMPANYNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY <> 'USA';

--NOT IN OPERATOR
--RETRIEVE CUSTOMERS NOT FROM UK, SPAIN, MEXICO, BRAZIL USA, ITALY, GERMANY
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY NOT IN ('UK', 'SPAIN', 'MEXICO', 'BRAZIL', 'USA', 'ITALY', 'GERMANY');

--RETRIEVE CUSTOMERS NOT FROM UK, SPAIN, MEXICO, BRAZIL USA, ITALY, GERMANY
--- AND CONTACT BEGINS WITH H
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY NOT IN ('UK', 'SPAIN', 'MEXICO', 'BRAZIL', 'USA', 'ITALY', 'GERMANY')
AND CONTACTNAME LIKE 'H%';


---STRING FUNCTIONS
--CAST() -- CONVERT A COLUMN DATA TYPE TO A DIFFERNT ONE DURING 
		-- A QUERY ROUTINE
--CONCAT() -- COMBINES THE VALUES IN TWO OR MORE COLUMNS
--LEFT() --- RETRIEVE A PORTION OF A STRING FROM THE LEFT
--RIGHT() -- RETRIEVE A PORTION OF A STRING FROM THE RIGHT
--SUBSTRING() -- RETRIEVES A PORTIION OF A STRING
--ISNULL() -- REPLACES A NULL VALUE WITH ANOTHER VALUE(ONLY TWO EVALUATIONS)
--COALESCE() -- REPLACES A NULL VALUE WITH ANOTHER VALUE
--LTRIM() -- REMOVE AN EMPTY SPACE FROM THE LEADING PORTION OF A STRING
--RTRIM() --REMOVE AN EMPTY SPACE FROM THE TRAILING PROTION OF A STRING
---CHARINDEX() -- USED TO FIND A SUBSTRING IN A STRING AND RETURNS ITS POSITION

--CAST()
DECLARE @NUMBER INT =125
DECLARE @NAME VARCHAR(10) = 'JUSTIN'
SELECT CAST (@NUMBER AS VARCHAR)+ @NAME

-- COMBINE EMLOYEEID AND EMPLOYEE LAST NAME
SELECT EMPID, LASTNAME
FROM HR.EMPLOYEES;

SELECT CAST(EMPID AS VARCHAR) + LASTNAME AS LOGINID
FROM HR.EMPLOYEES;

--- CONCAT()
DECLARE @LNAME VARCHAR(5) ='AK'
DECLARE @FNAME VARCHAR(10) = 'JUSTIN'
SELECT CONCAT(@FNAME,' ', @LNAME) AS FULLNAME

--COMBINE EMPLOYEE FIRST AND LAST NAME
SELECT CONCAT(FIRSTNAME,' ', LASTNAME) AS FULLNAME
FROM HR.EMPLOYEES

---- COMBINE EMLOYEEID AND EMPLOYEE LAST NAME
SELECT CONCAT(EMPID,' ',LASTNAME) LOGINID
FROM HR.EMPLOYEES;

---LEFT()
DECLARE @FNAME VARCHAR(10) = 'JUSTIN'
SELECT LEFT(@FNAME, 2) 

---RETRIEVE FIRST 3 CHARACTERS FROM  EMPLOYEES CITY
SELECT DISTINCT LEFT(CITY, 3) CITYABBRV
FROM HR.EMPLOYEES

----RIGHT()
DECLARE @FNAME VARCHAR(10) = 'JUSTIN'
SELECT RIGHT(@FNAME, 2) 

---RETRIEVE LAST 3 CHARACTERS FROM  EMPLOYEES CITY
SELECT DISTINCT RIGHT(CITY, 3) CITYABBRV, CITY
FROM HR.EMPLOYEES

---SUBSTRING()
DECLARE @FNAME VARCHAR(10) = 'JUSTIN'
SELECT SUBSTRING(@FNAME, 3, 3)

---RETRIEVE THE NEXT 3 CHARACTERS FROM  THE 2 POSITION IN EMPLOYEES CITY
SELECT DISTINCT SUBSTRING(CITY,2,3) CITYABBRV, CITY
FROM HR.EMPLOYEES


---CHARINDEX()
--RETRIEVE CHARACTERS PRECEEDING THE @ IN AN EMAIL
SELECT LEFT (EmailAddress,(CHARINDEX('@', EmailAddress))-1), [EmailAddress]
FROM [Person].[EmailAddress];

-----05/18/2022
---MATH FUNCTIONS
--ABS()  --RETURNS THE ABSOLUTE VALE
--FLOOR() -- RETURNS THE LARGEST INTEGER THAT IS <= A GIVEN DECIMAL VALUE
--CEILING() -- RETURNS THE SMALLEST INTEGER THAT IS >= A GIVEN DECIMAL VALUE
--ROUND() -- USED TO ROUND TO THE NEAREST WHOLE NUMBER
--POWER() -- USED TO FIND THE POWER OF GIVEN NUMBER
--SQRT() -- USED TO FIND THE SQUARE ROOT OF A GIVEN NUMBER

--ABS()
DECLARE @NUM INT = -7
SELECT @NUM VAL1, ABS(@NUM) VAL2;

--FLOOR()
DECLARE @NUM FLOAT = 57.6289
SELECT @NUM VAL1, FLOOR(@NUM) VAL2;

--CEILING()
DECLARE @NUM FLOAT = 7.23231
SELECT @NUM VAL1, CEILING(@NUM) VAL2;

--ROUND()
DECLARE @NUM FLOAT = 57.6289
SELECT @NUM VAL1, ROUND(@NUM, 2) VAL2

--POWER()
SELECT POWER(9,2) PWR;

--SQRT()
SELECT SQRT(70) SQUAREROOT

----DATE FUNCTIONS
--DATEDIFF()
--- HOW MANY DAYS SINCE 05/18/2000
SELECT  DATEDIFF(DAY, '05/18/2000', '05/18/2022') AS NUMOFDAYS

--- HOW MANY YEARS SINCE 09/11
SELECT  DATEDIFF(YEAR, '09/11/2001', '05/18/2022') AS NUMOFYEARS

--GETDATE()
SELECT GETDATE();

--- HOW MANY DAYS SINCE 05/18/2000
SELECT DATEDIFF(DAY, '05/18/2000', GETDATE()) AS NUMOFDAYS

--- DATEADD()
--WHAT WILL BE THE DATE 7 DAYS FROM NOW
SELECT DATEADD(DAY,7,GETDATE());

--WHAT WILL BE THE DATE 5 YEARS FROM NOW
SELECT DATEADD(YEAR,5,GETDATE());

--WHAT WILL BE THE DATE 6 MONTHS FROM NOW
SELECT DATEADD(MONTH,6,GETDATE());

--- DATEPART
--EXTRACT THE MONTH PART FROM TODAYS DATE
SELECT DATEPART(MONTH, GETDATE());

--EXTRACT THE YEARS PART FROM TODAYS DATE
SELECT DATEPART(YEAR, GETDATE());

--EXTRACT THE WEEKDAY PART FROM TODAYS DATE
SELECT DATEPART(WEEKDAY, GETDATE());

-- DATENAME()
SELECT DATENAME(WEEKDAY, '09/11/2001');

---HOW MANY YEARS SINCE 9/11
SELECT FLOOR(DATEDIFF(DAY, '09/11/2001', GETDATE())/365.25) NUMOFDAYS

----- JOINS
--INNER JOIN/ JOIN 
------retrieves matching records from the left and the right table
--LEFT JOIN/ LEFT OUTER JOIN 
------retrieves all records from the left table and matching 
-----records from the right table
--RIGHT JOIN/ RIGHT OUTER JOIN
------retrieves all records from the right table and matching 
-----records from the left table
---FULL JOIN/ FULL OUTER JOIN
----- retrieves all records from both left and right tables.
-----SELF JOIN 
-----conceptual join that allows to join a table to itself like its another table leveraging aliases.
---- CROSS JOIN 
---- cartesian join. which multiplies x amount of rows in the left to y 
---- amount of rows in the right table.

-- SYNTAX
--SELECT A.column1, B.coulmn2,...
--FROM table1 AS A
--JOIN table2 AS B
--ON A.commomcolumn = B.commoncolumn
---INNER JOIN/ JOIN

---RETRIEVE INFORMATION OF EMPLOYEES BORN AFTER 1987
--HUMANRESOURCES.EMPLOYEE
--PERSON.PERSON
SELECT *
FROM PERSON.PERSON 
JOIN HUMANRESOURCES.EMPLOYEE 
ON PERSON.PERSON.BUSINESSENTITYID = HUMANRESOURCES.EMPLOYEE.BUSINESSENTITYID;

SELECT P.TITLE, P.FIRSTNAME, P.LASTNAME, E.BIRTHDATE,P.PERSONTYPE
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON P.BUSINESSENTITYID = E.BUSINESSENTITYID
WHERE DATEPART(YEAR, E.BIRTHDATE) > '1987';

SELECT BIRTHDATE, DATEPART(YEAR, BIRTHDATE)
FROM HUMANRESOURCES.EMPLOYEE

---05/19/2022
---LEFT JOIN
--RETRIEVE ALL FIRST NAMES IN PERSONS TABLE THAT ARE ALSO CUSTOMERS
SELECT [FirstName]
FROM [Sales].[Customer] AS C
LEFT JOIN  [Person].[Person] AS P 
ON C.PersonID = P.[BusinessEntityID];

--RIGHT JOIN
--PULL SUPPLIERS WITH PRODUCTS
SELECT S.SUPPLIERID, S.COMPANYNAME, S.CONTACTNAME
FROM PRODUCTION.SUPPLIERS AS S
RIGHT JOIN PRODUCTION.PRODUCTS AS P
ON P.SUPPLIERID = S.SUPPLIERID

--LEFT TABLE = 1 3  7 9
--RIGHT TABLE = 1 2 3 4 5
--LEFT JOIN = 1 3 7 9
--RIGHT JOIN = 1 2 3 4 5

-- SELF JOIN
-- PULL A COMBINATION OF EMPLOYEE NAMES AND THEIR MANAGERS
SELECT CONCAT(E.FIRSTNAME,' ', E.LASTNAME)AS EMPLOYEE 
		, CONCAT(M.FIRSTNAME,' ', M.LASTNAME) AS MANAGER
FROM HR.EMPLOYEES AS E
LEFT JOIN HR.EMPLOYEES AS M
ON E.MGRID = M.EMPID

--CROSS JOIN
SELECT * FROM NUMS

---CREATE A TIMESHEET WITH 7 WORK DAYS AND 3 SHIFTS
SELECT D.N AS DOFWEEK, S.N AS SHIFTOFDAY
FROM NUMS AS D
CROSS JOIN NUMS AS S
WHERE D.N <=7 AND S.N <=3
ORDER BY D.N;

SELECT E.FIRSTNAME, C.CATEGORYNAME
FROM HR.EMPLOYEES AS E
CROSS JOIN PRODUCTION.CATEGORIES AS C;

SELECT COUNT(*) FROM HR.EMPLOYEES
SELECT COUNT(*) FROM PRODUCTION.CATEGORIES

SELECT 9*8

-- SET OPERATORS
--UNION
----RETRIEVE FIRSTNAMES THAT ARE BOTH EMPLOYEES AND CUSTOMERS WITHOUT DUPLICATION
SELECT DISTINCT  P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID ---224

UNION ---936

SELECT  DISTINCT P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID = P.BUSINESSENTITYID  ---871


--UNION ALL
----RETRIEVE FIRSTNAMES THAT ARE BOTH EMPLOYEES AND CUSTOMERS WITH DUPLICATION
SELECT DISTINCT  P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID ---224

UNION ALL ---1095

SELECT  DISTINCT P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID = P.BUSINESSENTITYID  ---871

--INTERSECT
--PULL ONLY FIRSTNAMES THAT ARE COMMON AMONG CUSTOMERS AND EMPLOYEES
SELECT DISTINCT  P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID ---224

INTERSECT ---159

SELECT  DISTINCT P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID = P.BUSINESSENTITYID  ---871

--EXCEPT
---RETRIEVE EMPLOYEE NAMES THAT ARE NOT CUSTOMER NAMES
SELECT DISTINCT  P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID ---224

EXCEPT ---65

SELECT  DISTINCT P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID = P.BUSINESSENTITYID  ---871

---RETRIEVE CUSTOMER NAMES THAT ARE NOT EMPLOYEE NAMES
SELECT  DISTINCT P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID = P.BUSINESSENTITYID  ---871

EXCEPT  ---712

SELECT DISTINCT  P.FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID ---224

---
SELECT PERSONID FROM SALES.CUSTOMER
EXCEPT
SELECT BUSINESSENTITYID FROM PERSON.PERSON


---05/23/2022
--CASE EXPRESSIONS

--SYNTAX
--CASE <specify the column_name>(if simple case expression)
	--WHEN <specify the conditional statement>
	--THEN <specify output if the condition is met>....
	--ELSE <specify output if none of the condition(s) is met>
--END AS <derived column>

--SEARCH FORM
--unitprice less than 20 then categorize as low
--unitprice between 20 and 50 then categorize as medium
--unit price is above 50 then categorize as high
select productid, productname, unitprice,
		case 
			when unitprice < 20 then 'low'
			when unitprice < 50 then 'medium'
			when unitprice >= 50 then 'high'
			else 'unknown'
		end as pricecategory
from Production.Products;

--SIMPLE FORM
SELECT CASE D.N 
			WHEN 1 THEN 'SUNDAY'
			WHEN 2 THEN 'MONDAY'
			WHEN 3 THEN 'TUESDAY'
			WHEN 4 THEN 'WEDNESDAY'
			WHEN 5 THEN 'THURSDAY'
			WHEN 6 THEN 'FRIDAY'
			ELSE 'SATURDAY'
		END AS DOFWEEK,
		CASE S.N 
			WHEN 1 THEN 'MORNING SHIFT'
			WHEN 2 THEN 'AFTERNOON SHIFT'
			ELSE 'OVERNIGHT SHIFT'
		END AS SHIFTOFDAY
FROM NUMS AS D
CROSS JOIN NUMS AS S
WHERE D.N <=7 AND S.N <=3
ORDER BY D.N;

----SUBQUERIES
--SELF CONTAINED SUBQUERY
------ the evaluation dpes not have any dependency on the outer query

--CORRELATED SUBQUERY
------ the evaluation depends on the outer query

---SYNTAX
--select column1, column2, column3.....
--from tablename
--where columnname (in. =, >, <>) (select column	
--								 from tablename)
--having aggregated_columnname (in. =, >, <>) (select column	
--								 from tablename)

--CORRELATED SUBQUERY
---retrieve products with minimum unitprice per category
select categoryid, productname, unitprice,
       case 
		   when discontinued = 1 then 'In Production'
		   else 'Not in Production'
	   end as ProductionStatus
from production.products as A
where unitprice = (select min(unitprice)
					from production.products AS B
					where A.categoryid = B.categoryid);
					
---SELF CONTAINED SUBQUERY
--retrieve product info for product with the max unitprice
select productid, productname, supplierid, categoryid, unitprice
from production.Products
where unitprice = (select max(unitprice)
					from Production.Products);

---TABLE EXPRESSIONS
-- DERIVED TABLE
--COMMON TABLE EXPRESSION(CTE)
--VIEWS
-- INLINE TABLE-VALUED FUNCTION

--DERIVED TABLE
--WINDOWING/ ANALYTICAL FUNCTIONS
--1. ROW_NUMBER -- gives a sequential row numbering over a partition
--2. RANK() -- skips ranking order when there is a tie over a partition
--3. DENSE_RANK() -- orders sequentially even when there is a tie over partition
--4. NTILE()-- gives the percentile over a partition

-- how rankings work
--column	Rank()	Dense_rank()	row_number()
	10		1		1				1
	11		2		2				2
	12		3		3				3
	14		3		3				4
	15		5		4				5
	16		5		4				6
	17		7		5				7

--DERIVED TABLE SYNTAX
--SELECT COLUMN(S)
--FROM (SELECT COLUMN(S)	
--	  FROM TABLENAME) AS A

-- retrieve the least 2 products per category based on unitprice
select productname , unitprice, categoryid
from(select productname , unitprice, categoryid,
	row_number() over(partition by categoryid order by unitprice) as ranking
	from production.products) as T
where ranking in (1,2);

----CTE SYNTAX
--WITH <CTE_NAME>
--AS 
--(
--INNER QUERY
--)
--OUTER QUERY

-- retrieve the least 2 products per category based on unitprice
with cte
as 
(
	select productname , unitprice, categoryid,
	row_number() over(partition by categoryid order by unitprice) as ranking
	from production.products
)

select productname , unitprice, categoryid
from cte
where ranking in (1,2);

---VIEWS
---A virtual table of a select query
--SYNTAX
--CREATE VIEW <viewname>
--AS
--<select_query>

--transforming query of the day into a view
CREATE VIEW SAMPLEVIEW
AS
select productname , unitprice, categoryid,
	row_number() over(partition by categoryid order by unitprice) as ranking
	from production.products;

SELECT * FROM SAMPLEVIEW
WHERE RANKING IN (1,2);





