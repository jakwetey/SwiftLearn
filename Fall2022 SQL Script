-----09/07/2022-----
---DATA DEFINITION LANGUAGE (DDL)
-- CREATE -- create databases/ tables/ schemas
---ALTER -- modify an existing table
---DROP --- remove or delete an entire table or constraint
---TRUNCATE -- removes all the records from a table but maintains the 
			-- structure.

---SYNTAX
-- CREATE DATABASE DATABASE_NAME;

--CREATING DATABASE STORE_DB
CREATE DATABASE STORE_DB;

--SYNTAX
--CREATE TABLE TABLE_NAME
--(
--COLUM1 DATATYPE CONSTRAINT,
--COLUMN2 DATATYPE COSTRAINT,
--COLUM3 DATATYPE CONSTRAINT,
--COLUMN4 DATATYPE COSTRAINT,
--....
--);

USE STORE_DB;

-- CREATING CUSTOMER TABLE
CREATE TABLE CUSTOMER
(
CUST_ID INTEGER NOT NULL,
F_NAME VARCHAR(50) NOT NULL,
L_NAME VARCHAR(50) NOT NULL,
DOB DATE NULL,
CITY VARCHAR(50) NOT NULL,
STATE CHAR(2) NOT NULL,
GENDER CHAR(1) NULL,
PHONE CHAR(10) NOT NULL
);

-- PRIMARY KEY IS A COLUMN OR A COMBINATION COLUMNS THAT IS 
--USED TO UNIQUELY IDENTIFY RECORDS IN A TABLE.

--SYNTAX
--ALTER TABLE TABLE_NAME
--ADD CONSTRAINT CONSTRAINT_NAME PRIMARY KEY(COLUMN);

-- ADDING PK CONSTRAINT TO CUSTOMER TABLE
ALTER TABLE CUSTOMER
ADD CONSTRAINT PK_CUSTOMER_CUST_ID PRIMARY KEY (CUST_ID);

--CREATING TABLE PRODUCT
CREATE TABLE PRODUCT
(
PROD_ID INTEGER IDENTITY(1000, 1),
P_NAME VARCHAR(20) NOT NULL,
PRICE MONEY NOT NULL,
SUPPLIER VARCHAR(20) NULL,
QUANTITY INTEGER NOT NULL
);

-- ADDING PRIMARY KEY TO PRODUCT TABLE
ALTER TABLE PRODUCT
ADD CONSTRAINT PK_PRODUCT_PROD_ID PRIMARY KEY (PROD_ID);

-- CREATING ORDERS TABLE
CREATE TABLE ORDERS
(
ORDER_ID INTEGER IDENTITY(100, 2),
CUST_ID INTEGER NOT NULL,
PROD_ID INTEGER NOT NULL,
ORDER_DATE DATE NOT NULL
);

-- ADDING PK TO ORDERS TABLE
ALTER TABLE ORDERS
ADD CONSTRAINT PK_ORDERS_ORDER_ID PRIMARY KEY(ORDER_ID);

--FOREIGN KEY
--A COLUMN IN ONE TABLE THAT REFERS TO THE PRIMARY KEY COLUMN IN 
----ANOTHER TABLE.
-- IT IS USED TO CREATE RELATIONSHIPS BETWEEN TABLES AND ALSO 
-----ENSURE REFERENTIAL INTEGRITY.

--SYNTAX
--ALTER TABLE TABLE_NAME
--ADD CONSTRAINT CONSTRAINT_NAME FOREIGN KEY(COLUMN)
--REFERENCES PARENT_TABLE (COLUMN);

--ADDING FK CONSTRAINT TO ORDERS TABLE
ALTER TABLE ORDERS
ADD CONSTRAINT FK_ORDERS_CUST_ID FOREIGN KEY(CUST_ID)
REFERENCES CUSTOMER(CUST_ID);

--ADDING FK CONSTRAINT TO ORDERS TABLE
ALTER TABLE ORDERS
ADD CONSTRAINT FK_ORDERS_PROD_ID FOREIGN KEY (PROD_ID)
REFERENCES PRODUCT(PROD_ID);

--ADDING SSN COLUMN TO CUSTOMER
ALTER TABLE CUSTOMER
ADD SSN CHAR(9) NOT NULL;

--CHANGING SSN DATATYPE
ALTER TABLE CUSTOMER
ALTER COLUMN SSN VARCHAR(9);

---DROP (COLUMN)
-- ALTER TABLE TABLE_NAME
--DROP COLUMN COLUMN_NAME

--DROP (TABLE)
--DROP TABLE TABLE_NAME

--REMOVING SSN COLUMN
ALTER TABLE CUSTOMER
DROP COLUMN SSN;

-- CREATING ORDERS1 TABLE
CREATE TABLE ORDERS1
(
ORDER_ID INTEGER IDENTITY(100, 2),
CUST_ID INTEGER NOT NULL,
PROD_ID INTEGER NOT NULL,
ORDER_DATE DATE NOT NULL
);

--REMOVIONG ORDERS1 TABLE
DROP TABLE ORDERS1;

--RENAMING ORDERS TABLE TO ORDER
EXEC SP_RENAME 'ORDER', 'ORDERS';

--RENAMING ORDER DATE COLUMN
EXEC sp_rename 'dbo.ORDER.ORDER_DATE', 'ORDER_DT', 'COLUMN';


------09/08/2022-------
--UNIQUE CONSTRAINT ENSURES THAT ALL VALUES IN A COLUMN ARE DISTINCT.
----- THERE CAN BE MORE THAN ONE UNIQUE CONSTRAINT DEFINED ON TABLE.

-- ADDING UNIQUE CONSTRAINT TO PRODUCT NAME COLUMN
ALTER TABLE PRODUCT
ADD CONSTRAINT UQ_PRODUCT_P_NAME UNIQUE(P_NAME);

--CHECK CONSTRAINT IT VERIFIES OR VALIDATES THAT ALL THE VALUES IN A FIELD
-- SATISFIES A GIVEN CONDITION.

--- ADDING CHECK CONSTRAINT THAT VALIDATES PHONE NUMBER LENGHT
ALTER TABLE CUSTOMER
ADD CONSTRAINT CK_CUSTOMER_PHONE CHECK (LEN(PHONE) = 10);

---INDEXES ARE USED TO RETRIEVE DATA FROM DATABASES MORE QUICK, THEY HELP SPEED UP QUERIES.
----CLUSTERED 
--Whenever you apply clustered indexing in a table, it will perform sorting 
--in that table only. You can create only one clustered index in a table like primary key.
--Clustered index is as same as dictionary where the data is arranged by alphabetical order. 
--If you apply primary key to any column, then automatically it will become clustered index. 

----NONCLUSTERED
--is similar to the index of a book. The index of a book consists of a chapter name and page number, 
--if you want to read any topic or chapter then you can directly go to that page by using index of
-- that book. No need to go through each and every page of a book. 

---SYNTAX
--CREATE <CLUSTERED/ NONCLUSTERED> INDEX_NAME
--ON TABLE_NAME(COLUMN);

--ADDING INDEX ON CUST_ID COLUMN
CREATE NONCLUSTERED INDEX IX_PRODUCT_P_NAME
ON PRODUCT (P_NAME);

CREATE NONCLUSTERED INDEX IX_ORDERS_CUST_ID
ON ORDERS (CUST_ID);

CREATE CLUSTERED INDEX IX_ORDERS_CUST_ID1
ON ORDERS (CUST_ID);

--REMOVING INDEX FROM PRODUCT TABLE
DROP INDEX  PRODUCT.IX_PRODUCT_P_NAME;

DROP INDEX  IX_PRODUCT_P_NAME
ON PRODUCT;

--DML COMMANDS (DATA MANIPULATION LANGUAGE)
--INSERT -- POPULATE RECORDS
--UPDATE -- MODIFY AN EXISTING RECORD BASED ON A GIVEN CONDITION
--DELETE -- REMOVE EXISTING RECORDS BASED ON A GIVEN CONDITION.
---------ALL RECORDS IN TABLE IS REMOVED WHEN NO CONDITION IS DEFINED
--SELECT -- RETIREVE RECORDS FROM ONE OR MORE TABLES.

---INSERT
--SYNTAX
--INSERT INTO TABLE_NAME(COLUMN1, COLUMN2, COLUMN3, ...)
--VALUES
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3');

--- POPULATING CUSTOMER TABLE
INSERT INTO CUSTOMER 
(CUST_ID, F_NAME, L_NAME, DOB, CITY, STATE, GENDER, PHONE)
VALUES
(1, 'JOHN', 'DOE', '05-20-1995', 'BALTIMORE', 'MD', 'M', '4109068975'),
(2, 'MARIA', 'AFOLABI', '09-01-1999', 'TAMPA', 'FL', 'F', '8137023478');

INSERT INTO CUSTOMER 
(CUST_ID, F_NAME, L_NAME, DOB, CITY, STATE, GENDER, PHONE)
VALUES
(4, 'UMAR', 'SMITH', '02-10-1995', 'COLUMBIA', 'MD', 'M', '4430985469');

--- POPULATING PRODUCT TABLE
INSERT INTO PRODUCT
(P_NAME, PRICE, SUPPLIER, QUANTITY)
VALUES
('MILO', 10.50, 'NESTLE', 27);

INSERT INTO PRODUCT
(P_NAME, PRICE, SUPPLIER, QUANTITY)
VALUES
('RICE', 30.99, 'SAMS CLUB', 27),
('SUGAR', 5.45, 'WALMART', 50),
('OIL', 15.90, 'SAMS CLUB', 72);

--POPULATING ORDERS TABLE
INSERT INTO ORDERS
(CUST_ID, PROD_ID, ORDER_DT)
VALUES
(4, 1000, '10-09-2021'),
(1, 1004, '01-15-2022');

INSERT INTO ORDERS
(CUST_ID, PROD_ID, ORDER_DT)
VALUES
(1, 2004, '01-15-2022');


-----09/12/2022--------
--UPDATE
--SYNTAX 
--UPDATE TABLENAME
--SET COLUMNNAME = 'VALUE'
--WHERE CONDITION

-- UPDATING CUSTOMER LAST NAME
UPDATE CUSTOMER
SET L_NAME = 'JONES'
WHERE CUST_ID = 1;

---ADDING LAST NAME COLUMN TO ORDERS TABLE
ALTER TABLE ORDERS
ADD CUST_LNAME VARCHAR(50);

--UPDATE CUSTOMER LAST NAME DYNAMICALY
UPDATE ORDERS
SET CUST_LNAME = CUSTOMER.L_NAME
FROM ORDERS, CUSTOMER
WHERE ORDERS.CUST_ID = CUSTOMER.CUST_ID;

----TRUNCATE
TRUNCATE TABLE ORDERS;

-- DELETE
-- REMOVING ORDER 104
DELETE 
FROM  ORDERS
WHERE ORDER_ID = 104;

---REMOVING ALL RECORDS FROM ORDERS TABLE
DELETE 
FROM  ORDERS;

--KEYED IN ORDER
--SELECT -- RETRIEVE THE DATA, LIST OF COLUMNS(DERIVED)
--FROM -- SPECIFY THE TABLE(S) WHERE COLUMNS RESIDE
--WHERE -- USED TO FILTER RECORDS ON A GIVEN CONDITION(NON-AGGREGATED COLUMNS)
--GROUP BY -- USED TO GROUP NON-AGGREGATED COLUMNS WHEN AN AGGREGATE FUCTION
			-- IS INTRODUCED AT THE SELECT.
--HAVING -- USED TO FILTER RECORDS ON A GIVEN CONDITION(AGGREGATED COLUMNS)
--ORDER BY -- USED TO ORDER RECORDS. BY DEFAULT ITS IN ASCENDING(ASC) 
	--ELSE DESCENDING(DESC)

---LOGICAL QUERY ORDER
--FROM
--WHERE
--GROUP BY
--HAVING
--SELECT
--ORDER BY

--AGGREGATE FUNCTIONS
--SUM() 
--COUNT()
--AVERAGE() / AVG()
--MAX()
--MIN()

---RETRIEVE THE MOST EXPENSIVE ORDER IN THE ORDERS TABLE
SELECT MAX(FREIGHT) AS MAXFREIGHT
FROM SALES.ORDERS;

-- RETREIVE THE TOTAL NUMBER OF CUSTOMERS 
SELECT COUNT(CUSTID) AS NUMOFCUSTOMERS
FROM SALES.CUSTOMERS;

--- RETRIEVE THE TOTAL SUM OF CUSTOMER FREIGHT
SELECT CUSTID, SUM(FREIGHT) AS TOTALFREIGHT
FROM SALES.ORDERS
GROUP BY CUSTID
ORDER BY CUSTID;

--DISTINCT -- ALLOW RETREIVAL OF NON DUPLICATED VALUES/ RECORDS
SELECT DISTINCT CUSTID 
FROM SALES.ORDERS;

--SQL OPERATORS
--AND  -- ALL CONDITIONS MUST BE TRUE
--OR -- AT LEAST ONE CONDITION MUST BE TRUE
--BETWEEN -- IS USED AS A SEARCH PREDICATE  FRO A RANGE OF ITEMS 
--		-- ALWAYS USED WITH AND OPERATOR
--IN -- ALLOWS TO CREATE A SET PREDICATE FOR A GROUP OF ITEMS
----LIKE -- ALLOWS TO PERFORM PATTERN SEARCH.
--		-- USED IN CUNJUCTION WITH A WILD CARD (%, _)
--= --- EQUAL TO
--<> OR != -- NOT EQUAL TO
--> -- GREATER THAN 
--< -- LESS THAN

-- RETRIEVE ORDERS PLACED  FROM JUNE 2006 TO MAY 2007
SELECT ORDERID, CUSTID, ORDERDATE 
FROM SALES.ORDERS
WHERE ORDERDATE BETWEEN '06-01-2006' AND '05-01-2007'

SELECT ORDERID, CUSTID, ORDERDATE 
FROM SALES.ORDERS
WHERE ORDERDATE >= '06-01-2006' AND ORDERDATE <= '05-01-2007'

-- RETRIEVE A LIST ORDERS OF ORDERS THAT FREIGHT IS LESS THAN $100 OR
--MORE THAN $500
SELECT ORDERID, CUSTID, ORDERDATE, FREIGHT 
FROM SALES.ORDERS
WHERE FREIGHT < 100 OR FREIGHT > 500
ORDER BY FREIGHT;

-----09/13/2022------
-- RETRIEVE CUSTOMERS THAT ARE FROM SPAIN, FRANCE, CANADA, UK, USA
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY IN ('SPAIN', 'FRANCE', 'CANADA', 'UK', 'USA');


SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY = 'SPAIN' OR COUNTRY = 'FRANCE'OR COUNTRY = 'CANADA'
		OR COUNTRY = 'UK' OR COUNTRY = 'USA';

--LIKE OPERATOR
-- WILDCARDS
-----_ REPRESENTS A SINGLE CHARACTER
-----% REPRESENTS MULTIPLE CHARACTERS

--- RETRIEVE CUSTOMERS THAT HAVE THE LETTER P IN THIER COUNTRY NAME.
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '%P%'

--- RETRIEVE CUSTOMERS THAT HAVE THE LETTER A IN THIER COUNTRY NAME.
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '%A%'


--- RETRIEVE CUSTOMERS THAT WHOSE COUNTRY NAME START WITH THE LETTER B
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE 'B%'

--- RETRIEVE CUSTOMERS THAT WHOSE COUNTRY NAME END WITH THE LETTER A
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '%A'

--RETRIEVE CUSTOMERS THAT WHOSE COUNTRY NAME HAS THE LETTER N IN THE 3RD POSITION
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '__N%'

SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE 'F_N%';

---!=/ <>
-- RETREIVE CUSTOMERS NOT FROM USA
SELECT CUSTID, CONTACTNAME, COMPANYNAME, CONTACTTITLE, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY <> 'USA';

SELECT CUSTID, CONTACTNAME, COMPANYNAME, CONTACTTITLE, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY != 'USA';

-- NOT IN OPERATOR
-- RETRIEVE CUSTOMERS THAT ARE NOT FROM SPAIN, FRANCE, CANADA, UK, USA
SELECT CUSTID, CONTACTNAME, COMPANYNAME, CONTACTTITLE, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY NOT IN ('SPAIN', 'FRANCE', 'CANADA', 'UK', 'USA');

---STRING FUNCTIONS
--CAST() -- CONVERT A COLUMN DATA TYPE TO A DIFFERNT ONE DURING 
		-- A QUERY ROUTINE
--CONCAT() -- COMBINES THE VALUES IN TWO OR MORE COLUMNS
--LEFT() --- RETRIEVE A PORTION OF A STRING FROM THE LEFT
--RIGHT() -- RETRIEVE A PORTION OF A STRING FROM THE RIGHT
--SUBSTRING() -- RETRIEVES A PORTIION OF A STRING
--ISNULL() -- REPLACES A NULL VALUE WITH ANOTHER VALUE(ONLY TWO EVALUATIONS)
--COALESCE() -- REPLACES A NULL VALUE WITH ANOTHER VALUE
--LTRIM() -- REMOVE AN EMPTY SPACE FROM THE LEADING PORTION OF A STRING
--RTRIM() --REMOVE AN EMPTY SPACE FROM THE TRAILING PROTION OF A STRING
---CHARINDEX() -- USED TO FIND A SUBSTRING IN A STRING AND RETURNS ITS POSITION
--LEN() -- USED TO FIND HOW MANY CHARACTERS ARE IN A STRING

--LEN()
-- RETRIEVE EMPLOYEES AND THE LENGHT OF THEIR LASTNAMES
SELECT EMPID, FIRSTNAME, LASTNAME, LEN(LASTNAME) AS LNAMELEN
FROM HR.EMPLOYEES;

--CONCAT()
--PULL CUSTOMER INFORMATION WITH THEIR LOCATIONS AS A COMBINATION OF 
--CITY AND COUNTRY
SELECT COMPANYNAME, CONTACTNAME, PHONE, CONCAT(CITY,' - ',COUNTRY) AS LOCATION
FROM SALES.CUSTOMERS

---ISNULL()
--RETREIVE CUSTOMERS INFORMATION AND REPLACE CUSTOMERS REGION THAT IS NULL 
--TO NA
SELECT COMPANYNAME, CONTACTNAME, PHONE, CITY , 
		ISNULL(REGION,'NA') AS REGION , REGION
FROM SALES.CUSTOMERS

--COALESCE()
SELECT CUSTID, COMPANYNAME, CONTACTNAME, PHONE, CITY,
COALESCE(REGION, FAX, POSTALCODE) AS REGION
FROM SALES.CUSTOMERS

SELECT *
FROM SALES.CUSTOMERS

--LEFT() / RIGHT()
-- RETRIEVE THE FIRST 3 CHARACTERS FROM CUSTOMER CITY
SELECT DISTINCT CITY, LEFT (CITY, 3) ABV
FROM SALES.CUSTOMERS

-- RETRIEVE THE LAST 3 CHARACTERS FROM CUSTOMER CITY
SELECT DISTINCT CITY, RIGHT(CITY, 3) ABV
FROM SALES.CUSTOMERS;

---SUBSTRING()
--RETREIVE THE 4 CHARACTERS FROM THE 3RD POSITION IN THE CUSTOMER CITY
SELECT DISTINCT SUBSTRING(CITY,3,4) AS SUBSTR, CITY
FROM SALES.CUSTOMERS;

--CHARINDEX()
--RETRIEVE CHARACTERS PRECEEDING THE @ IN THE EMAIL.
SELECT LEFT(EMAILADDRESS, CHARINDEX('@', EMAILADDRESS)-1)
		, EMAILADDRESS
FROM [Person].[EmailAddress]


---09/14/2022----
--MATH FUNCTIONS
-- ABS() -- RETURNS THE  ABSOLUTE VALUE  OF A NUMBER
--FLOOR() -- RETRUNS THE LARGEST INTEGER THAT IS <= A GIVEN DECIMAL VALUE
--CEILING() -- RETRUNS THE SMALLEST INTEGER THAT IS >= A GIVEN DECIMAL VALUE
--ROUND() -- USED TO ROUND A VALUE TO THE NEAREST WHOLE NUMBER
--POWER() -- USED TO FIND THE POWER OF A GIVEN NUMBER
--SQRT() -- USED TO FOND THE SQUARE ROOT OF A GIVEN NUMBER.

---ABS()
DECLARE @NUM INT = -10
SELECT @NUM AS VAL1, ABS(@NUM ) AS VAL2

--FLOOR() 
DECLARE @NUM FLOAT = 75.556
SELECT @NUM AS VAL1, FLOOR(@NUM) AS VAL2;

---CEILING()
DECLARE @NUM FLOAT = 52.956
SELECT @NUM AS VAL1, CEILING(@NUM) AS VAL2;

--ROUND
DECLARE @NUM FLOAT = 52.95623
SELECT @NUM AS VAL1, ROUND(@NUM,2) AS VAL2;

--POWER
SELECT POWER(9,8) PWR

--SQRT
SELECT SQRT(64) SQROOT;

---DATE FUNCTIONS
-- DATEDIFF()
-- HOW MANY DAYS SINCE 911
SELECT DATEDIFF(DAY, '09/11/2001', GETDATE()) NUMOFDAYS;

-- DATEADD() 
--WHAT WILL THE DATE BE 100 DAYS FROM TODAY
SELECT DATEADD(DAY, 100, GETDATE()) 

-- GETDATE() 
SELECT GETDATE()

-- DATEPART() 
--EXTRACT DAY PART OF TODAYS DATE
SELECT DATEPART(DAY, GETDATE())

-- DATENAME()
-- FIND THE WEEKDAY FOR TODAYS DATE
SELECT DATENAME(WEEKDAY, GETDATE())

SELECT DATENAME(WEEKDAY, '05/17/1997')

--CURRENT_TIMESTAMP
SELECT CURRENT_TIMESTAMP


--Table 1 Query:
Create Table EmployeeDemographics 
(EmployeeID int, 
FirstName varchar(50), 
LastName varchar(50), 
Age int, 
Gender varchar(50)
)

--Table 2 Query:
Create Table EmployeeSalary 
(EmployeeID int, 
JobTitle varchar(50), 
Salary int
)


---TABLES USED IN JOIN SCENERIOS
--Table 1 Insert:
Insert into EmployeeDemographics VALUES
(1001, 'Jim', 'Halpert', 30, 'Male'),
(1002, 'Pam', 'Beasley', 30, 'Female'),
(1003, 'Dwight', 'Schrute', 29, 'Male'),
(1004, 'Angela', 'Martin', 31, 'Female'),
(1005, 'Toby', 'Flenderson', 32, 'Male'),
(1006, 'Michael', 'Scott', 35, 'Male'),
(1007, 'Meredith', 'Palmer', 32, 'Female'),
(1008, 'Stanley', 'Hudson', 38, 'Male'),
(1009, 'Kevin', 'Malone', 31, 'Male'),
(NULL, 'Joe', 'Hallow', 20, NULL),
(NULL, 'Timmy', 'Toms', NULL, NULL),
(NULL, 'Gigi', 'Buffon', 34, 'Male');


--Table 2 Insert:
Insert Into EmployeeSalary VALUES
(1001, 'Salesman', 45000),
(1002, 'Receptionist', 36000),
(1003, 'Salesman', 63000),
(1004, 'Accountant', 47000),
(1005, 'HR', 50000),
(1006, 'Regional Manager', 65000),
(1007, 'Supplier Relations', 41000),
(1008, 'Salesman', 48000),
(1009, 'Accountant', 42000),
(NULL, NULL, 49000),
(NULL, 'Receptionist', 55000);


----- JOINS-----
--JOINS ARE USED TO RETRIEVE DATA FROM TWO OR MORE TABLES BASED ON A LOGICAL
--RELATIONSHIP BETWEEN THE TABLES

--INNER JOIN/ JOIN 
------retrieves matching records from the left and the right table
--LEFT JOIN/ LEFT OUTER JOIN 
------retrieves all records from the left table and matching 
-----records from the right table
--RIGHT JOIN/ RIGHT OUTER JOIN
------retrieves all records from the right table and matching 
-----records from the left table
---FULL JOIN/ FULL OUTER JOIN
----- retrieves all records from both left and right tables.
-----SELF JOIN 
-----conceptual join that allows to join a table to itself like its another table leveraging aliases.
---- CROSS JOIN 
---- cartesian join. which multiplies x amount of rows in the left to y 
---- amount of rows in the right table.

-- SYNTAX
--SELECT A.coumn1, B.column2
--FROM TABLE1 AS A
--JOIN TABLE2 AS B
--ON A.COMMONCOLUMN = B.COMMONCOLUMN;

--JOIN
SELECT * 
FROM EMPLOYEEDEMOGRAPHICS AS D
JOIN EMPLOYEESALARY AS S
ON D.EMPLOYEEID = S.EMPLOYEEID;

--- LEFT JOIN
SELECT * 
FROM EMPLOYEEDEMOGRAPHICS AS D
LEFT JOIN EMPLOYEESALARY AS S
ON D.EMPLOYEEID = S.EMPLOYEEID;

--RIGHT JOIN
SELECT * 
FROM EMPLOYEEDEMOGRAPHICS AS D
RIGHT JOIN EMPLOYEESALARY AS S
ON D.EMPLOYEEID = S.EMPLOYEEID;

--FULL JOIN
SELECT * 
FROM EMPLOYEEDEMOGRAPHICS AS D
FULL JOIN EMPLOYEESALARY AS S
ON D.EMPLOYEEID = S.EMPLOYEEID;

--- RETRIEVE INFORMATION OF EMPLOYEES BORN AFTER 1990
SELECT P.BUSINESSENTITYID,P.FIRSTNAME, P.LASTNAME, E.JOBTITLE, E.BIRTHDATE
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON P.BUSINESSENTITYID = E.BUSINESSENTITYID
WHERE YEAR(E.BIRTHDATE) > '1990'

SELECT P.BUSINESSENTITYID,P.FIRSTNAME, P.LASTNAME, E.JOBTITLE, E.BIRTHDATE
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON P.BUSINESSENTITYID = E.BUSINESSENTITYID
WHERE DATEPART(YEAR, E.BIRTHDATE) > '1990';

----09/15/2022----
---RETREIVE ALL SUPPLIERS AND PRODUCTS THAT THEY SUPPLY. INCLUDE SUPPLIERS
---WITH NO ASSOCCIATED PRODUCTS.
SELECT S.SUPPLIERID, S.COMPANYNAME, S.CONTACTNAME, S.COUNTRY, P.PRODUCTNAME
FROM PRODUCTION.SUPPLIERS AS S
LEFT JOIN PRODUCTION.PRODUCTS AS P
ON S.SUPPLIERID = P.SUPPLIERID

----RETRIEVE ALL CUSTOMERS AND THEIR ORDERS. INCLUDE CUSTOMERS WITHOUT ORDERS
---FLAG CUSTOMERS WITH NO ORDERID AS "NO ORDERS PLACED"
SELECT C.CUSTID, C.COMPANYNAME, C.CONTACTNAME, C.COUNTRY, 
		ISNULL(CAST(O.ORDERID AS VARCHAR),'NO ORDERS PLACED') AS ORDERID
FROM SALES.CUSTOMERS AS C
LEFT JOIN SALES.ORDERS AS O
ON C.CUSTID = O.CUSTID
ORDER BY ORDERID DESC;


--RIGHT JOIN
----RETRIEVE ALL CUSTOMERS AND THEIR ORDERS. INCLUDE CUSTOMERS WITHOUT ORDERS
---FLAG CUSTOMERS WITH NO ORDERID AS "NO ORDERS PLACED"
SELECT C.CUSTID, C.COMPANYNAME, C.CONTACTNAME, C.COUNTRY, 
		ISNULL(CAST(O.ORDERID AS VARCHAR),'NO ORDERS PLACED') AS ORDERID
FROM SALES.ORDERS AS O  
RIGHT JOIN SALES.CUSTOMERS AS C
ON C.CUSTID = O.CUSTID
ORDER BY ORDERID DESC;

---SELF JOIN
--PULL EMPLOYEES AND THEIR MANAGER.
SELECT CONCAT(E.FIRSTNAME,' ', E.LASTNAME) EMPLOYEE
		,CONCAT(M.FIRSTNAME,' ', M.LASTNAME) MANAGER
FROM HR.EMPLOYEES AS E
LEFT JOIN HR.EMPLOYEES AS M
ON E.MGRID = M.EMPID

---CROSS JOIN
SELECT FIRSTNAME, COMPANYNAME
FROM HR.EMPLOYEES
CROSS JOIN PRODUCTION.SUPPLIERS

SELECT D.N AS WEEK_DAY , S.N SHIFTS
FROM NUMS AS D
CROSS JOIN NUMS AS S
WHERE D.N <=7 AND S.N <=3
ORDER BY WEEK_DAY;

----SET OPERATORS
---SET OPERATORS
--UNION used to unify the result data sets of 2 or more queries WITHOUT duplicates
--UNION ALL used to unify the result data sets of 2 or more queries WITH duplicates
--INTERSECT  is used to retrieve only the rows that exist in both tables and is ditinct
--EXCEPT used to perfom set difference; so it will return distinct rows that appear in 
      ---the first result data set that are not in the second result data 

--- THINGS TO REMEMBER
-- the number of selcted columns must be the same 
-- their data types must be the same 

--UNION
--RETRIEVE  FIRSTNAMES THAT ARE BOTH EMPLOYEES AND CUSTOMERS WITHOUT  DUPS
SELECT  DISTINCT  FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID  --224

-UNION ---936

SELECT DISTINCT FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID =P.BUSINESSENTITYID  --871
ORDER BY FIRSTNAME


--UNION ALL
--RETRIEVE  FIRSTNAMES THAT ARE BOTH EMPLOYEES AND CUSTOMERS WITH DUPS
SELECT  DISTINCT  FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID  --224

UNION ALL---1095

SELECT DISTINCT FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID =P.BUSINESSENTITYID  --871
ORDER BY FIRSTNAME

--INTERSECT
---- RETRIEVE NAMES THAT ARE COMMON BEWEEN EMPLOYEES AND CUSTOMERS
SELECT  DISTINCT  FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID  --224

INTERSECT---159

SELECT DISTINCT FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID =P.BUSINESSENTITYID  --871
ORDER BY FIRSTNAME

---EXCEPT
--PULL NAMES THAT ARE EMPLOYEES BUT NIT CUSTOMERS
SELECT  DISTINCT  FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID  --224

EXCEPT--65

SELECT DISTINCT FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID =P.BUSINESSENTITYID  --871
ORDER BY FIRSTNAME

----RETREIVE NAMES THAT ARE CUSTOMERS BUT NOT EMPLOYEES
SELECT DISTINCT FIRSTNAME
FROM PERSON.PERSON AS P
JOIN SALES.CUSTOMER AS C
ON C.PERSONID =P.BUSINESSENTITYID  --871

EXCEPT

SELECT  DISTINCT  FIRSTNAME
FROM PERSON.PERSON AS P
JOIN HUMANRESOURCES.EMPLOYEE AS E
ON E.BUSINESSENTITYID = P.BUSINESSENTITYID  --224
ORDER BY 1

SELECT *
FROM  CUSTOMER
WHERE CUSTOMERID IN (1, 2, 3, 4, 5.....999)

UNION ALL

SELECT *
FROM  CUSTOMER
WHERE CUSTOMERID IN (1000, ...1800)

-----09/19/2022-----
--CASE  EXPRESSIONS
-- PROVIDES A CONDITIONAL LOGIC FROM A RETURNED VALUE

-- SIMPLE CASE EXPRESSION
-- SEARCH CASE EXPRESSION

--SYNTAX
--CASE <column_name>(if simple case expression)
--	WHEN<specify the conditional statement>
--	THEN <specify the output if condition is met>....
--	ELSE <specify output if none the condition(s) is/are met>
--END AS <alias>

--SIMPLE CASE EXPRESSION
SELECT D.N AS WEEK_DAY , S.N SHIFTS
FROM NUMS AS D
CROSS JOIN NUMS AS S
WHERE D.N <=7 AND S.N <=3
ORDER BY WEEK_DAY;

SELECT CASE D.N
			WHEN 1 THEN 'SUNDAY'
			WHEN 2 THEN 'MONDAY'
			WHEN 3 THEN 'TUESDAY'
			WHEN 4 THEN 'WEDNESDAY'
			WHEN 5 THEN 'THURSDAY'
			WHEN 6 THEN 'FRIDAY'
			ELSE 'SATURDAY'
		END AS WEEK_DAY,
		CASE S.N 
			WHEN 1 THEN 'MORNING SHIFT'
			WHEN 2 THEN 'AFTERNOON SHIFT'
			ELSE 'OVERNIGHT SHIFT'
		END AS SHIFTS
FROM NUMS AS D
CROSS JOIN NUMS S
WHERE D.N <=7 AND S.N <=3
ORDER BY D.N;

---SERACH CASE EXPRESSION
--UNITPRICE LESS THAN 50 IS LOW
--UNIT PRICE BETWEEN 50 AND 100 IS MEDIUM 
--UNIT PRICE ABOVE 100 IS HIGH
SELECT PRODUCTID, PRODUCTNAME, UNITPRICE ,
	   CASE 
			WHEN UNITPRICE < 50 THEN 'LOW'
			WHEN UNITPRICE BETWEEN 50 AND 100 THEN 'MEDIUM'
			WHEN UNITPRICE > 100 THEN 'HIGH'
			ELSE  'UNKNOWN'
		END AS PRICECATEGORY
FROM PRODUCTION.PRODUCTS;

----SUBQUERY
--SELF CONTAINED SUBQUERY
----the evalution of the inner does not depend on the outer query

--CORRELATED SUBQUERY
----the evalution of the inner depends on the outer query

SYNTAX
--SELECT COLUMN1, COLUMN2, COLUMN3...
--FROM TABLENAME
--WHERE COLUMN  <<IN, =,!=, >,...>> (SELECT COLUMN	
--									FROM TABLENAME)
--HAVING AGGREGATED_COLUMN <<IN, =,!=, >,...>> (SELECT COLUMN	
--											 FROM TABLENAME)

--- RETRIEVE PRODUCTS WITH MINIMUM UNITPRICE PER CATEGORY
SELECT CATEGORYID, PRODUCTNAME, UNITPRICE
FROM PRODUCTION.PRODUCTS AS A 
WHERE UNITPRICE = (SELECT MIN(UNITPRICE)
					FROM PRODUCTION.PRODUCTS AS B
					WHERE A.CATEGORYID = B.CATEGORYID);

---SELF CONTAINED SUBQUERY
--- RETRIEVE INFORMATION FOR PRODUCT WITH THE HIGHEST UNIT PRICE
SELECT PRODUCTID, PRODUCTNAME, SUPPLIERID, CATEGORYID, UNITPRICE
FROM PRODUCTION.PRODUCTS
WHERE UNITPRICE = (SELECT MAX(UNITPRICE)
					FROM PRODUCTION.PRODUCTS)

--SELECT TOP 1 PRODUCTID, PRODUCTNAME, SUPPLIERID, CATEGORYID, UNITPRICE
--FROM PRODUCTION.PRODUCTS
--ORDER BY UNITPRICE DESC

---TABLE EXPRESSIONS
--DERIVED TABLE
--COMMON TABLE EXPRESSION(CTE)
--VIEWS
--INLINE TABLE-VALUED FUNCTION

--WINDOWING/ ANALYTICAL FUNCTIONS
--1. ROW_NUMBER -- gives a sequential row numbering over a partition
--2. RANK() -- skips ranking order when there is a tie over a partition
--3. DENSE_RANK() -- orders sequentially even when there is a tie over partition
--4. NTILE()-- gives the percentile over a partition


--COLUMN	RANK()		DENSE_RANK()	ROW_NUMBER()
	10			1			1				1
	11			2			2				2
	12			2			2				3
	13			4			3				4
	14			5			4				5
	15			6			5				6
	16			6			5				7
	17			8			6				8
	18			9			7				9

--- DERIVED TABLES SYNTAX
--SYNTAX
--SELECT COLUMN(S)
--FROM (SELECT COLUMN(S)
--	  FROM TABLENAME) AS A;

---RETREIVE CUSTOMER INFORMATION AND THE MOST RECENT PRODUCT(S) PURCHASED
SELECT CUSTID,COMPANYNAME, PRODUCTNAME, ORDERDATE
FROM
(
	SELECT C.CUSTID,C.COMPANYNAME, P.PRODUCTNAME, O.ORDERDATE,
			DENSE_RANK() OVER(PARTITION BY C.CUSTID ORDER BY O.ORDERDATE DESC) RANKING
	FROM SALES.CUSTOMERS C
	JOIN SALES.ORDERS O
	ON C.CUSTID = O.CUSTID
	JOIN SALES.ORDERDETAILS OD
	ON OD.ORDERID = O.ORDERID
	JOIN PRODUCTION.PRODUCTS P
	ON P.PRODUCTID = OD.PRODUCTID
) DERIVEDTABLE
WHERE RANKING = 1

---CTE 
--SYNTAX
--WITH <CTE_NAME>
--AS
--(
--INNER QUERY
--)
--OUTER QUERY


WITH CTE 
AS
(
SELECT C.CUSTID,C.COMPANYNAME, P.PRODUCTNAME, O.ORDERDATE,
			DENSE_RANK() OVER(PARTITION BY C.CUSTID ORDER BY O.ORDERDATE DESC) RANKING
	FROM SALES.CUSTOMERS C
	JOIN SALES.ORDERS O
	ON C.CUSTID = O.CUSTID
	JOIN SALES.ORDERDETAILS OD
	ON OD.ORDERID = O.ORDERID
	JOIN PRODUCTION.PRODUCTS P
	ON P.PRODUCTID = OD.PRODUCTID
)

SELECT CUSTID,COMPANYNAME, PRODUCTNAME, ORDERDATE
FROM CTE 
WHERE RANKING = 2

