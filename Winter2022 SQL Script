-------5/11/2022-------
---DATA DEFINITION LANGUAGE (DDL) COMMAMDS
--CREATE -- create databases/tables/schemas
--ALTER -- modifies an existing table
---DROP -- remove or delete an entire table or constraint
--TRUNCTATE -- removes all records from a table but maintans the structure.

---SYNTAX
-- CREATE DATABASE DATABASENAME;

--CREATEING DATABASE COMPANY_DB
CREATE DATABASE COMPANY_DB;

----SYNTAX
--CREATE TABLE TABLENAME
--(
--COLUMNNAME DATATYPE CONSTRAINT,
--COLUMNNAME2 DATATYPE CONSTRAINT,
--COLUMNNAME3 DATATYPE CONSTRAINT,
--COLUMNNAME4 DATATYPE CONSTRAINT,
--...
--);

--CREATING EMPLOYEE TABLE
CREATE TABLE EMPLOYEE
(
EMP_ID  INT IDENTITY(1000, 1),
FNAME VARCHAR(50) NOT NULL,
LNAME VARCHAR(50) NOT NULL,
DOB DATE NOT NULL,
GENDER CHAR(1) NULL,
PHONE CHAR(10) NULL,
CITY VARCHAR(20) NOT NULL,
STATE CHAR(2) NOT NULL,
ZIP CHAR(5) NOT NULL
);

---PRIMARY KEY IS A UNIQUE IDENTIFIER IN A TABLE

-- SYNTAX
--ALTER TABLE TABLENAME
--ADD CONSTRAINT CONSTRAINTNAME PRIMARY KEY(COLUMNNAME);

--ADDING PK TO EMPLOYEE TABLE
ALTER TABLE EMPLOYEE
ADD CONSTRAINT PK_EMPLOYEE_EMP_ID PRIMARY KEY (EMP_ID);

--CREATING DEPARTMENT TABLE
CREATE TABLE DEPARTMENT
(
DEP_ID VARCHAR(5) NOT NULL,
DEP_NAME VARCHAR(50) NOT NULL,
DEP_STATE CHAR(2) NULL
);

-- ADDING PK CONSTRAINT
ALTER TABLE DEAPARTMENT
ADD CONSTRAINT PK_DEPARTMENT_DEP_ID PRIMARY KEY (DEP_ID);


--SYNTAX
--ALTER TABLE TABLENAME
--ADD COLUMNNMAE DATATYPE CONSTRAINT;

---ADDING COLUMN TO EMPLOYEE
ALTER TABLE EMPLOYEE
ADD DEP_ID VARCHAR(5) NOT NULL;

--FOREIGN KEY
-- A COLUMN OR FIELD IN ONE TABLE THAT REFERS TO THE PRIMARY KEY COLUMN IN 
--ANOTHER TABLE.

--SYNTAX
--ALTER TABLE CHILDTABLE
--ADD CONSTRAINT CONSTRAINTNME FOREIGN KEY (COLUMN)
--REFERENCES PARENTTABLE(COLUMN)

--ADDING FK TO EMPLOYEE TABLE
ALTER TABLE EMPLOYEE
ADD CONSTRAINT FK_EMPLOYEE_DEP_ID FOREIGN KEY(DEP_ID)
REFERENCES DEPARTMENT(DEP_ID);

---RENAMING TABLE
EXEC SP_RENAME 'DEAPARTMENT', 'DEPARTMENT';

-- SYNTAX
--ALTER TABLE TABLENAME
--ALTER COLUMN COLUMNNAME DATATYPE CONSTRAINT;

--MODIFYING PHONE DATATYPE
ALTER TABLE EMPLOYEE
ALTER COLUMN PHONE CHAR(12);

--ADDING SSN COLUMN 
ALTER TABLE EMPLOYEE
ADD SSN CHAR(9) NOT NULL;

--DROP
--SYNTAX
--ALTER TABLE TABLENAME
--DROP COLUMN COLUMNNAME;

---REMOVING SSN COLUMN
ALTER TABLE EMPLOYEE
DROP COLUMN SSN;

--UNIQUE CONSTRAINT ENSURES THAT ALL VALUES IN A COLUMN ARE DISTINCT.
--AND THERE CAN BE MORE THAN ONE DEFINED ON A TABLE

--ADDING UNIQUE CONSTRAINT TO SSN COLUMN
ALTER TABLE EMPLOYEE 
ADD CONSTRAINT UQ_EMPLOYEE_SSN UNIQUE(SSN);

-- DEFAULT CONSTRAINT WILL AUTOMATICALLY ASSIGN A VALUE IF NO VALUE WAS INSTERED.
-- ADDING DEFAULT VALUE OF N FOR GENDER WHEN NO VALUE IS SPECIFIED
ALTER TABLE EMPLOYEE
ADD CONSTRAINT DFT_EMPLOYEE_GENDER DEFAULT ('N') FOR GENDER;

--CHECK CONSTRAINT VERIFIES THAT ALL VALUES IN A FIELD SATISFY A GIVEN CONDITION.
-- ADDING CHECK TO VERIFY EMPLOYEE STATE
ALTER TABLE EMPLOYEE
ADD CONSTRAINT CHK_EMPLOYEE_STATE CHECK (STATE IN ('DC', 'MD', 'VA'));


-------5/12/2022-------
---ADDING CHECK CONSTRAINT TO VERIFY SSN LENGHT
ALTER TABLE EMPLOYEE
ADD CONSTRAINT CHK_EMPLOYEE_SSN CHECK (LEN(SSN) = 9);

CREATE TABLE DEPARTMENT1
(
DEP_ID VARCHAR(5) NOT NULL,
DEP_NAME VARCHAR(50) NOT NULL,
DEP_STATE CHAR(2) NULL
);

---DROP
--SYNTAX
--DROP TABLE TABLENAME

--DELETING DEPARTMENT1 TABLE
DROP TABLE DEPARTMENT1;

--TRUNCATE 
--SYNTAX
--TRUNCATE TABLE TABLENAME

---SYNTAX
--ALTER TABLE TABLENAME
--DROP COLUMN COLUMNNAME;

---REMOVING DEP_STATE COLUMN FROM DEPARTMENT1 TABLE
ALTER TABLE DEPARTMENT1
DROP COLUMN DEP_STATE;

---SYNTAX
--ALTER TABLE TABLENAME
--ADD  COLUMNNAME DATATYPE CONSTRAINT;

--- ADDING A HEADCOUNT COLUMN TO DEPARTMENT1 TABLE
ALTER TABLE DEPARTMENT1
ADD HEADCOUNT INTEGER NOT NULL;

---INDEXES ARE USED TO RETRIEVE DATA FROM DATABASES MORE QUICK, THEY HELP SPEED UP QUERIES.
----CLUSTERED 
--Whenever you apply clustered indexing in a table, it will perform sorting 
--in that table only. You can create only one clustered index in a table like primary key.
--Clustered index is as same as dictionary where the data is arranged by alphabetical order. 
--If you apply primary key to any column, then automatically it will become clustered index. 

----NONCLUSTERED
--is similar to the index of a book. The index of a book consists of a chapter name and page number, 
--if you want to read any topic or chapter then you can directly go to that page by using index of
-- that book. No need to go through each and every page of a book. 

---SYNTAX
--CREATE <CLUSTERED/ NONCLUSTERED> INDEXNAME ON TABLENAME(COLUMNNAME)

---CREATING INDEX ON PHONE COLUMN
CREATE NONCLUSTERED INDEX IDX_EMPLOYEE_PHONE ON EMPLOYEE(PHONE);

---SYNTAX
--DROP INDEX TABLENAME.INDEXNAME

--- REMOVING INDEX FROM PHONE COLUMN
DROP INDEX EMPLOYEE.IDX_EMPLOYEE_PHONE;

---DML COMMANDS (DATA MANIPULATION LAMGUAGE)
--INSERT POPULATE RECORDS
--UPDATE MODIFIES AN EXISTING RECORD BASED ON A GIVEN CONDITION
--DELETE REMOVES EXISTING RECORDS(BASED ON A GIVEN CONDITION)
--SELECT RETRIEVE RECORDS FROM ONE OR MORE TABLES.

--INSERT
--SYNTAX
--INSERT INTO TABLENAME (COLUMN1, COLUMN2, COLUMN3,...)
--VALUES 
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3'),
--('VALUE1', 'VALUE2', 'VALUE3');

--POPULATING DEPARTMENT TABLE
INSERT INTO DEPARTMENT (DEP_ID, DEP_NAME, DEP_STATE)
VALUES
(00001, 'IT', 'CA'),
(00002, 'CLAIMS', 'OH'),
(00003, 'UNDERWRITTING', 'DE'),
(00004, 'CUSTOMER', 'MD'),
(00005, 'SALES', NULL);

--RETRIEVING FROM DEPARTMENT TABLE
SELECT * FROM DEPARTMENT;

INSERT INTO DEPARTMENT (DEP_ID, DEP_NAME)
VALUES
(00011, 'CALL CENTER');

---POPULATING EMPLOYEE TABLE
INSERT INTO EMPLOYEE (FNAME, LNAME,DOB, GENDER, PHONE, CITY, STATE, ZIP,DEP_ID,SSN)
VALUES
('JOHN', 'SMITH', '05-10-1990', 'M', '443-123-9876', 'BALTIMORE', 'MD', '21117',00001, '123456789'),
('DAVE', 'JONES', '03-10-1800', 'M', '443-478-9876', 'COLUMBIA', 'MD', '21617',00005, '123457489'),
('EBONY', 'ALEZ', '05-10-1997', 'F', '813-123-9876', 'RESTON', 'VA', '20117',00003, '123456009'),
('DESTINY', 'OSEI', '01-10-2000', 'F', '440-123-9876', 'WASHINGTON', 'DC', '61117',00001, '003456789'),
('MICHAEL', 'DOE', '05-10-1990', 'M', '443-123-9006', 'BALTIMORE', 'MD', '21117',00002, '124866789');

--RETRIEVING FROM EMPLOYEES TABLE
SELECT * FROM EMPLOYEE

INSERT INTO EMPLOYEE (FNAME, LNAME,DOB, GENDER, PHONE, CITY, STATE, ZIP,DEP_ID,SSN)
VALUES
('JOHN', 'SAGE', '05-10-1990', 'M', '443-123-9876', 'HOUSTON', 'DC', '21117',00011, '734067999');

---UPDATE 
---SYNTAX
--UPDATE TABLENAME
--SET COLUMNNAME = 'NEWVALUE'
--WHERE CONDITION

---UPDATING EMPLOYEE PHONE NUMBER
UPDATE EMPLOYEE
SET PHONE = '701-677-9321'
WHERE EMP_ID = 1002;

--UPDATING EMPLOYEE LASTNAME
UPDATE EMPLOYEE
SET LNAME = 'RENDEL'
WHERE EMP_ID = 1003;


------05/16/2022
ALTER TABLE EMPLOYEE
ADD DEPARTMENT VARCHAR(20);

SELECT * FROM EMPLOYEE
SELECT * FROM DEPARTMENT

-- UPDATING EMPLOYEE TABLE TO DYNAMICALLY POLULATE DEPARTMENT COLUMN
UPDATE EMPLOYEE
SET DEPARTMENT = DEPARTMENT.DEP_NAME
FROM EMPLOYEE, DEPARTMENT
WHERE EMPLOYEE.DEP_ID = DEPARTMENT.DEP_ID

---DELETE
---SYNTAX 
--DELETE 
--FROM TABLE NAME
--WHERE CONDITION (---IF THERE IS NO CONDITION THEN EVERY RECORD WILL BE DELETED)

---- REMOVING EMPLOYEE JOHN SAGE RECORD
DELETE
FROM EMPLOYEE
WHERE EMP_ID = 1012;

SELECT * FROM EMPLOYEE;

DELETE 
FROM EMPLOYEE;

----REMOVE ALL RECORDS FROM DEPARTMENT
TRUNCATE TABLE DEPARTMENT;

SELECT * FROM DEPARTMENT;

-- REMOVING FK CONSTRAINT
ALTER TABLE EMPLOYEE
DROP [FK_EMPLOYEE_DEP_ID];

SELECT * FROM EMPLOYEE

---REMOVING EMPLOYEE TABLE FROM COMPANYDB
DROP TABLE EMPLOYEE;


--KEYED IN ORDER
--SELECT -- RETRIEVE THE DATE. LIST OF COLUMNS, DERIVED COLUMNS(AGGREGATED)
--FROM -- SPECIFIES THE TABLE(S) WHERE COLUMNS ARE SITUATED
--WHERE -- USED TO FILTER RECORDS ON A GIVEN CONDITION (NON-AGGREGATED COLUMNS)
--GROUP BY -- USED TO GROUP NON-AGGREGATED COLUMNS WHENEVER AN AGGREGATED FUNCTION IS 
			-- INTRODUCED IN THE SELECT
--HAVING -- USED TO FILTER AGGREGATED COLUMNS
--ORDER BY -- USED TO SORT OR ORDER RECODS. BY DEFAULT IN ASCENDING(ASC) 
			--OTHERWISE DESCENDING (DESC).

--LOGICAL  QUERY ORDER
--FROM
--WHERE
--GROUP BY
--HAVING
--SELECT 
--ORDER BY


--AGGREGATE FUNCTIONS
--SUM()
--COUNT()
--AVERAGE() / AVG()
--MAX()
--MIN()

--- F(X) = 2X + 4
--- F(2) = 2(2) + 4 = 8

---FIND THE HIGHEST UNIT PRICE ACROSS ALL PRODUCTS
SELECT MAX(UNITPRICE) AS MAXPRICE
FROM PRODUCTION.PRODUCTS;

SELECT UNITPRICE
FROM PRODUCTION.PRODUCTS
ORDER BY UNITPRICE DESC;

-- WHAT IS THE TOTAL NUMBER OF EMPLOYEES IN OUR COMPANY?
SELECT COUNT(EMPID) AS NUMOFEMPLOYEES
FROM HR.EMPLOYEES;

--FIND THE TOTAL UNITPRICE PER CATEGORY
SELECT CATEGORYID, SUM(UNITPRICE) AS TOTAL
FROM PRODUCTION.PRODUCTS
GROUP BY CATEGORYID
ORDER BY CATEGORYID;


--DISTINCT -- ALLOW RETRIEVAL OF NON DUPLICATED RECORDS
SELECT DISTINCT CATEGORYID
FROM PRODUCTION.PRODUCTS

---SQL OPERATORS
--AND -- ALL CONDITIONS MUST BE TRUE
--OR -- AT LEAST ONE CONDITION MUST BE TRUE
--BETWEEN IS USED AS A SEARCH PREDICATE FOR A RANGE OF ITEMS(ALWAYS USED WITH AND)
--IN -- ALLOWS TO CREATE A SET PREDICATE FOR A SET OF ITEMS
--LIKE -- ALLOWS TO PERFORM PATTERN SEARCH. 
		-- MUST BE ALWAYS USED WITH A WILDCARD FOR A GIVEN SEARCH.

-- PULL ORDERS PLACED FROM 11/2006 TO 11/2007
SELECT ORDERID, ORDERDATE
FROM SALES.ORDERS
WHERE ORDERDATE BETWEEN '11-01-2006' AND '11-01-2007'
ORDER BY ORDERDATE DESC;

SELECT ORDERID, ORDERDATE
FROM SALES.ORDERS
WHERE ORDERDATE >= '11-01-2006' AND ORDERDATE <= '11-01-2007';

--RETRIEVE A LIST OF PRODUCTS THAT UNTPRICE IS LESS THAN $10 OR MORE THAN $50
SELECT PRODUCTID, PRODUCTNAME, UNITPRICE
FROM PRODUCTION.PRODUCTS
WHERE UNITPRICE < 10 OR UNITPRICE > 50
ORDER BY UNITPRICE;

SELECT DISTINCT CUSTID, ORDERID
FROM SALES.ORDERS;


---05/17/2022
SELECT * FROM SALES.CUSTOMERS

--IN OPERATOR
--RETRIEVE CUSTOMERS FROM UK, SPAIN, MEXICO, BRAZIL USA, ITALY
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY IN ('UK', 'SPAIN', 'MEXICO', 'BRAZIL', 'USA', 'ITALY');

SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY ='UK' OR COUNTRY = 'SPAIN'OR COUNTRY = 'MEXICO'
		OR COUNTRY ='BRAZIL' OR COUNTRY = 'USA' OR COUNTRY = 'ITALY';

--LIKE OPERATOR
-- WILDCARDS(%, _)
-----% REPRESENTS MULTIPLE CHARACTERS
-----  _ REPRESENTS A SINGLE CHARACTER

SELECT DISTINCT COUNTRY
FROM SALES.CUSTOMERS

---PULL ALL CUSTOMER COUNTRIES THAT HAVE THE LETTER Z IN THERE
SELECT  DISTINCT COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '%Z%';

---PULL ALL CUSTOMER COUNTRIES THAT BEGIN WITH THE LETTER B.
SELECT DISTINCT COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE 'B%'

---PULL ALL CUSTOMER COUNTRIES THAT HAS THE LETTER 'A' IN THE 4TH POSITION.
SELECT DISTINCT COUNTRY 
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '___A%'

---PULL ALL CUSTOMER COUNTRIES THAT ENDS WITH LETTER D
SELECT DISTINCT COUNTRY 
FROM SALES.CUSTOMERS
WHERE COUNTRY LIKE '%D';

---!= / <>
-- RERIEVE CUSTOMERS NOT FROM USA
SELECT CUSTID, COMPANYNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY != 'USA';

SELECT CUSTID, COMPANYNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY <> 'USA';

--NOT IN OPERATOR
--RETRIEVE CUSTOMERS NOT FROM UK, SPAIN, MEXICO, BRAZIL USA, ITALY, GERMANY
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY NOT IN ('UK', 'SPAIN', 'MEXICO', 'BRAZIL', 'USA', 'ITALY', 'GERMANY');

--RETRIEVE CUSTOMERS NOT FROM UK, SPAIN, MEXICO, BRAZIL USA, ITALY, GERMANY
--- AND CONTACT BEGINS WITH H
SELECT CUSTID, COMPANYNAME, CONTACTNAME, COUNTRY
FROM SALES.CUSTOMERS
WHERE COUNTRY NOT IN ('UK', 'SPAIN', 'MEXICO', 'BRAZIL', 'USA', 'ITALY', 'GERMANY')
AND CONTACTNAME LIKE 'H%';


---STRING FUNCTIONS
--CAST() -- CONVERT A COLUMN DATA TYPE TO A DIFFERNT ONE DURING 
		-- A QUERY ROUTINE
--CONCAT() -- COMBINES THE VALUES IN TWO OR MORE COLUMNS
--LEFT() --- RETRIEVE A PORTION OF A STRING FROM THE LEFT
--RIGHT() -- RETRIEVE A PORTION OF A STRING FROM THE RIGHT
--SUBSTRING() -- RETRIEVES A PORTIION OF A STRING
--ISNULL() -- REPLACES A NULL VALUE WITH ANOTHER VALUE(ONLY TWO EVALUATIONS)
--COALESCE() -- REPLACES A NULL VALUE WITH ANOTHER VALUE
--LTRIM() -- REMOVE AN EMPTY SPACE FROM THE LEADING PORTION OF A STRING
--RTRIM() --REMOVE AN EMPTY SPACE FROM THE TRAILING PROTION OF A STRING
---CHARINDEX() -- USED TO FIND A SUBSTRING IN A STRING AND RETURNS ITS POSITION

--CAST()
DECLARE @NUMBER INT =125
DECLARE @NAME VARCHAR(10) = 'JUSTIN'
SELECT CAST (@NUMBER AS VARCHAR)+ @NAME

-- COMBINE EMLOYEEID AND EMPLOYEE LAST NAME
SELECT EMPID, LASTNAME
FROM HR.EMPLOYEES;

SELECT CAST(EMPID AS VARCHAR) + LASTNAME AS LOGINID
FROM HR.EMPLOYEES;

--- CONCAT()
DECLARE @LNAME VARCHAR(5) ='AK'
DECLARE @FNAME VARCHAR(10) = 'JUSTIN'
SELECT CONCAT(@FNAME,' ', @LNAME) AS FULLNAME

--COMBINE EMPLOYEE FIRST AND LAST NAME
SELECT CONCAT(FIRSTNAME,' ', LASTNAME) AS FULLNAME
FROM HR.EMPLOYEES

---- COMBINE EMLOYEEID AND EMPLOYEE LAST NAME
SELECT CONCAT(EMPID,' ',LASTNAME) LOGINID
FROM HR.EMPLOYEES;

---LEFT()
DECLARE @FNAME VARCHAR(10) = 'JUSTIN'
SELECT LEFT(@FNAME, 2) 

---RETRIEVE FIRST 3 CHARACTERS FROM  EMPLOYEES CITY
SELECT DISTINCT LEFT(CITY, 3) CITYABBRV
FROM HR.EMPLOYEES

----RIGHT()
DECLARE @FNAME VARCHAR(10) = 'JUSTIN'
SELECT RIGHT(@FNAME, 2) 

---RETRIEVE LAST 3 CHARACTERS FROM  EMPLOYEES CITY
SELECT DISTINCT RIGHT(CITY, 3) CITYABBRV, CITY
FROM HR.EMPLOYEES

---SUBSTRING()
DECLARE @FNAME VARCHAR(10) = 'JUSTIN'
SELECT SUBSTRING(@FNAME, 3, 3)

---RETRIEVE THE NEXT 3 CHARACTERS FROM  THE 2 POSITION IN EMPLOYEES CITY
SELECT DISTINCT SUBSTRING(CITY,2,3) CITYABBRV, CITY
FROM HR.EMPLOYEES


---CHARINDEX()
--RETRIEVE CHARACTERS PRECEEDING THE @ IN AN EMAIL
SELECT LEFT (EmailAddress,(CHARINDEX('@', EmailAddress))-1), [EmailAddress]
FROM [Person].[EmailAddress];























